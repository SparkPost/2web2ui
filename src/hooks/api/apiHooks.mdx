import { Meta, Story, Preview, Props } from '@storybook/addon-docs/blocks';

<Meta title="Hooks|API Hooks" />

`useSparkPostQuery` is a wrapper for React Query's
[useQuery](https://react-query.tanstack.com/docs/api#usequery) hook that adds some additional error
handling and defaults for interfacing with SparkPost APIs. A thorough understanding of the
`useQuery` API and its defaults is beneficial when leveraging `useSparkPostQuery`.

## Examples

Functions that return request configuration can be found in `src/helpers/api`. These functions
return basic information leveraged by [axios](https://github.com/axios/axios) to make asynchronous
requests. These helper functions also return a unique data structure that serve as the query's
unique [query key](https://react-query.tanstack.com/docs/guides/queries#query-keys).

### Basic

```js
import React from 'react';
import { useSparkPostQuery } from 'src/hooks';
import { getAccount, getSubscription } from 'src/helpers/api';

function MyComponent() {
  const { data, status } = useSparkPostQuery(getAccount);

  if (status === 'loading') return 'Loading...';

  if (status === 'error') return 'Sorry, something went wrong.';

  return (
    <div>
      <p>Here is your data, sir or madame:</p>

      {data}
    </div>
  );
}
```

### Handling Parameters

Some requests accept params, and can be passed like so:

```js
const { data, status } = useSparkPostQuery(() => getAccount({ myParamIsGreat: true }));
```

### Configuring `useQuery`

For each instance of `useSparkPostQuery`, a custom `config` object can be supplied. Any
[options](https://react-query.tanstack.com/docs/api#usequery) that `useQuery` can accept can be
passed in here.

```js
const { data, status } = useSparkPostQuery(getAccount, { enabled: false });
```

### Parallel Requests

Multiple, parallel requests can be made via multiple instances of `useSparkPostQuery`. For example

```js
function MyComponent() {
  const { data: accountData, status: accountStatus } = useSparkPostQuery(getAccount);
  const { data: subscriptionData, status: subscriptionStatus } = useSparkPostQuer(getSubscription);

  if (accountStatus === 'loading' || subscriptionStatus === 'loading') return 'Loading...';

  if (accountStatus === 'error' || subscriptionStatus === 'error')
    return 'Sorry, something went wrong.';

  return (
    <div>
      <p>Here is your data, sir or madame:</p>

      {accountData}
      {subscriptionData}
    </div>
  );
}
```

## useSparkPostQueries

Similar to useSparkPostQuery, but can be passed in multiple request configurations. This is used
when data is codependent and can dynamically accept a number of requests. This should NOT be used in
preference over running a known number of parallel requests as in the previous example. Defer to
using `useSparkPostQuery` instead.

```js
const queries = useSparkPostQueries([...dynamicRequests], {
  enabled: Boolean(reportOptions.isReady && groupBy && reformattedMetrics.length),
  refetchOnWindowFocus: false,
});
```

## useSparkPostMutation

Use [mutations](https://react-query.tanstack.com/guides/mutations) to handle PUT and POST requests
via the `useSparkPostMutation` hook. This hook accepts a mutation function and mutation
configuration options as arguments. For more detail, read the API docs for the `react-query` hook:
[useMutation](https://react-query.tanstack.com/reference/useMutation).

```js
import { addTodo } from 'src/helpers/api/todos';

const mutation = useSparkPostMutation(newTodo => addTodo(newTodo), {
  onSuccess: () => window.alert('This is a success callback'),
});

function MyComponent() {
  const newTodo = {
    name: 'say hello to my little friend.',
    status: 'incomplete',
  };
  return (
    <div>
      {mutation.status === 'idle' && (
        <button onClick={() => mutation.mutate(newTodo)}>Add New Todo</button>
      )}

      {mutation.status === 'loading' && <p>Loading...</p>}

      {mutation.status === 'error' && <p>Something went wrong</p>}

      {mutation.status === 'success' && <p>You added a new todo! Woohoo!</p>}
    </div>
  );
}
```
